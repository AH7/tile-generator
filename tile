#!/usr/bin/env python

import click
import sys
import os
import yaml

PATH = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(PATH, 'lib'))
import build

CONFIG_FILE = "tile.yml"

@click.group()
def cli():
	pass

@cli.command('init')
@click.argument('name', nargs=1, required=False)
def init_cmd(name):
	if name is not None:
		os.mkdir(name)
		os.chdir(name)
	if os.path.isfile(CONFIG_FILE):
		print >>sys.stderr, 'Already initialized.'
		sys.exit(0)
	name = os.path.basename(os.getcwd())
	config = {
		'name': name
	}
	write_config(config)

@cli.command('build')
@click.argument('version', 'patch', required=False)
@click.option('--verbose', is_flag=True)
@click.option('--dry-run', is_flag=True)
def build_cmd(version, verbose, dry_run):
	config = read_config()
	build.update_version(config, version)
	build.build(config, verbose)
	if not dry_run:
		write_config(config)

def read_config():
	try:
		with open(CONFIG_FILE) as config_file:
			return read_yaml(config_file)
	except IOError as e:
		print >> sys.stderr, 'Not a tile repository. Use "tile init" in the root of your repository to create one.'
		sys.exit(1)

def write_config(config):
	with open(CONFIG_FILE, 'wb') as config_file:
		write_yaml(config_file, config)

def read_yaml(file):
	return yaml.safe_load(file)

def write_yaml(file, data):
	file.write('---\n')
	file.write(yaml.dump(data, default_flow_style=False))

if __name__ == "__main__":
	cli()
