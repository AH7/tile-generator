#!/usr/bin/env python

import sys
import click
import yaml
import json
import requests
import time

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# This function assumes that we are executing from within a concourse
# pool-resource repository, where the claimed PCF instance metadata
# is available in a file named './metadata'
#
def get_credentials():
	try:
		with open('metadata') as cred_file:
			creds = yaml.safe_load(cred_file)
			creds['opsmgr']
			creds['opsmgr']['url']
			creds['opsmgr']['username']
			creds['opsmgr']['password']
			creds['cf']
			creds['cf']['url']
			creds['cf']['username']
			creds['cf']['password']
	except KeyError as e:
		print >> sys.stderr, 'metadata file is missing a value:', e.message
		sys.exit(1)
	except IOError as e:
		print >> sys.stderr, 'Not a Concourse PCF pool resource.'
		print >> sys.stderr, 'Execute this from within the pool repository root, after a successful claim/acquire.'
		sys.exit(1)
	return creds

def opsmgr_get(url, stream=False):
	creds = get_credentials()
	url = creds.get('opsmgr').get('url') + url
	username = creds.get('opsmgr').get('username')
	password = creds.get('opsmgr').get('password')
	headers = { 'Accept': 'application/json' }
	response = requests.get(url, auth=(username, password), verify=False, headers=headers, stream=stream)
	opsmgr_check_response(response)
	return response

def opsmgr_post(url, payload):
	creds = get_credentials()
	url = creds.get('opsmgr').get('url') + url
	username = creds.get('opsmgr').get('username')
	password = creds.get('opsmgr').get('password')
	response = requests.post(url, auth=(username, password), verify=False, data=payload)
	opsmgr_check_response(response)
	return response

def opsmgr_post_yaml(url, filename, payload):
	creds = get_credentials()
	url = creds.get('opsmgr').get('url') + url
	username = creds.get('opsmgr').get('username')
	password = creds.get('opsmgr').get('password')
	files = { filename: yaml.safe_dump(payload) }
	response = requests.post(url, auth=(username, password), verify=False, files=files)
	opsmgr_check_response(response)
	return response

def opsmgr_upload(url, filename):
	creds = get_credentials()
	url = creds.get('opsmgr').get('url') + url
	username = creds.get('opsmgr').get('username')
	password = creds.get('opsmgr').get('password')
	files = { 'product[file]': open(filename, 'rb') }
	response = requests.post(url, auth=(username, password), verify=False, files=files)
	opsmgr_check_response(response)
	return response

def opsmgr_delete(url, check_response=True):
	creds = get_credentials()
	url = creds.get('opsmgr').get('url') + url
	username = creds.get('opsmgr').get('username')
	password = creds.get('opsmgr').get('password')
	response = requests.delete(url, auth=(username, password), verify=False)
	opsmgr_check_response(response, check_response=check_response)
	return response

def opsmgr_check_response(response, check_response=True):
	if check_response and response.status_code != requests.codes.ok:
		print >> sys.stderr, '-', response.status_code
		try:
			errors = response.json()["errors"]
			print >> sys.stderr, '- '+('\n- '.join(errors))
		except:
			print >> sys.stderr, response.text
		sys.exit(1)

def opsmgr_get_products():
	available_products = opsmgr_get('/api/products').json()
	installed_products = opsmgr_get('/api/installation_settings').json()['products']
	for product in available_products:
		installed = [ p for p in installed_products if p['identifier'] == product['name'] and p['product_version'] == product['product_version'] ]
		product['installed'] = len(installed) > 0
	return available_products

def opsmgr_configure(settings, product, properties):
	#
	# Use the first availability zone
	#
	infrastructure = settings['infrastructure']
	product_settings = [ p for p in settings['products'] if p['identifier'] == product ][0]
	product_settings['availability_zone_references'] = [ az['guid'] for az in infrastructure['availability_zones'] ]
	product_settings['singleton_availability_zone_reference'] = infrastructure['availability_zones'][0]['guid']
	#
	# Make sure Elastic Runtime tile is installed
	#
	cf = [ p for p in settings['products'] if p['identifier'] == 'cf' ]
	if len(cf) < 1:
		print >> sys.stderr, 'Required product Elastic Runtime is missing'
		sys.exit(1)
	#
	# Use the Elastic Runtime stemcell
	#
	stemcell = cf[0]['stemcell']
	print '- Using stemcell', stemcell['name'], 'version', stemcell['version']
	product_settings['stemcell'] = stemcell
	#
	# Insert supplied properties
	#
	missing_properties = []
	for p in product_settings['properties']:
		key = p['identifier']
		value = properties.get(key, None)
		if value is not None:
			p['value'] = value
		else:
			if p.get('value', None) is None:
				missing_properties += [ key ]
	if len(missing_properties) > 0:
		print >> sys.stderr, 'Input file is missing required properties:'
		print >> sys.stderr, '- ' + '\n- '.join(missing_properties)
		sys.exit(1)

@click.group()
def cli():
	pass

@cli.command('products')
def products_cmd():
	products = opsmgr_get_products()
	for product in products:
		print "-", product["name"], product["product_version"], "(installed)" if product["installed"] else ""

@cli.command('is-available')
@click.argument('product')
@click.argument('version')
def is_available_cmd(product, version):
	products = opsmgr_get_products()
	matches = [ p for p in products if p['name'] == product and p['product_version'] == version ]
	if len(matches) < 1:
		print >> sys.stderr, 'No match found for product', product, 'version', version
		sys.exit(1)

@cli.command('is-installed')
@click.argument('product')
@click.argument('version')
def is_installed_cmd(product, version):
	products = opsmgr_get_products()
	matches = [ p for p in products if p['name'] == product and p['product_version'] == version and p['installed'] ]
	if len(matches) < 1:
		print >> sys.stderr, 'Product', product, 'version', version, 'is not installed'
		sys.exit(1)

@cli.command('configure')
@click.argument('product')
@click.argument('properties_file')
def configure_cmd(product, properties_file):
	with open(properties_file) as f:
		properties = yaml.safe_load(f)
	settings = opsmgr_get('/api/installation_settings').json()
	opsmgr_configure(settings, product, properties)
	opsmgr_post_yaml('/api/installation_settings', 'installation[file]', settings)

@cli.command('settings')
@click.argument('product', None, required=False)
def settings_cmd(product):
	settings = opsmgr_get('/api/installation_settings').json()
	if product is not None:
		settings = [ p for p in settings['products'] if p['identifier'] == product ]
		if len(settings) < 1:
			print >> sys.stderr, 'No settings found for product', product
			sys.exit(1)
		settings = settings[0]
	print json.dumps(settings, indent=4)

@cli.command('import')
@click.argument('zipfile')
def import_cmd(zipfile):
	opsmgr_upload('/api/products', zipfile)

@cli.command('install')
@click.argument('product')
@click.argument('version')
def install_cmd(product, version):
	payload = {
		'name': product,
		'product_version': version,
	}
	opsmgr_post('/api/installation_settings/products', payload)

@cli.command('delete-unused-products')
def delete_unused_products_cmd():
	opsmgr_delete('/api/products')

@cli.command('backup')
@click.argument('backup_file')
def backup_cmd(backup_file):
	response = opsmgr_get('/api/installation_asset_collection', stream=True)
	with open(backup_file, 'wb') as f:
		for chunk in response.iter_content(1024):
			f.write(chunk)

@cli.command('restore')
@click.argument('backup_file')
def restore_cmd(backup_file):
	with open(backup_file, 'rb') as f:
		payload = { 'installation[file]': f }
		opsmgr_post('/api/installation_asset_collection', f)

@cli.command('cleanup')
@click.argument('product')
def cleanup_cmd(product):
	#
	# Attempt 1 - Delete any uninstalled versions
	#
	products = opsmgr_get('/api/installation_settings/products').json()
	matches = [ p for p in products if p['type'] == product ]
	for match in matches:
		print >> sys.stderr, '- attempting to delete', match['name']
		opsmgr_delete('/api/installation_settings/products/' + match['guid'])
		opsmgr_delete('/api/products')
	products = opsmgr_get('/api/installation_settings/products').json()
	matches = [ p for p in products if p['type'] == product ]
	if len(matches) < 1:
		sys.exit(0)
	if len(matches) > 1:
		print >> sys.stderr, '- more than one match remains installed'
		sys.exit(1)
	#
	# Attempt 2 - Uninstall deployed version
	#
	match = matches[0]
	print >> sys.stderr, '- product was deployed, applying changes to uninstall it'
	apply_changes_cmd()
	opsmgr_delete('/api/products')
	products = opsmgr_get('/api/installation_settings/products').json()
	matches = [ p for p in products if p['type'] == product ]
	if len(matches) < 1:
		sys.exit(0)
	#
	# Attempt 3 - Re-deploy with errands disabled, then uninstall
	#
	match = matches[0]
	print >> sys.stderr, '- uninstall appears to have failed'
	print >> sys.stderr, '- re-deploying with disabled errands'
	opsmgr_disable_errands(product)
	apply_changes_cmd()
	print >> sys.stderr, '- uninstalling with disabled errands'
	opsmgr_delete('/api/installation_settings/products/' + match['guid'])
	apply_changes_cmd()
	opsmgr_delete('/api/products')
	products = opsmgr_get('/api/installation_settings/products').json()
	matches = [ p for p in products if p['type'] == product ]
	if len(matches) > 0:
		print >> sys.stderr, '- failed to uninstall'
		sys.exit(1)

@cli.command('apply-changes')
def apply_changes_cmd():
	install = opsmgr_post('/api/installation', { 'ignore_warnings': 'true' }).json()['install']
	lines_shown = 0
	while True:
		log_lines = opsmgr_get('/api/installation/' + str(install['id']) + '/logs').json()['logs'].splitlines()
		for line in log_lines[lines_shown:]:
			if not line.startswith('{'):
				print ' ', line
		lines_shown = len(log_lines)
		install_status = opsmgr_get('/api/installation/' + str(install['id'])).json()['status']
		if not install_status == 'running':
			break
		time.sleep(1)

if __name__ == '__main__':
	cli()